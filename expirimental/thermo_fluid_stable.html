<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>LBM Fluid Simulation – Thermal Forcing with Temperature Memory</title>
  <style>
    body {
      margin: 0;
      background: #222;
      color: #eee;
      font-family: sans-serif;
      user-select: none;
    }
    #controls {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 20;
      background: rgba(0,0,0,0.85);
      padding: 10px;
      border-radius: 4px;
      max-width: 320px;
    }
    #controls > div {
      margin-bottom: 5px;
    }
    /* Editor controls; hidden by default */
    .editorControls {
      display: none;
      margin-top: 10px;
      border-top: 1px solid #555;
      padding-top: 10px;
    }
    canvas {
      display: block;
      margin: 0 auto;
      background: #000;
    }
    label { font-size: 0.9em; }
    /* Startup overlay styles */
    #startupControls {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.95);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 100;
      flex-direction: column;
    }
    #startupControls input {
      width: 80px;
      margin: 5px;
    }
    #startupControls label {
      margin: 5px;
    }
  </style>
</head>
<body>
<div id="startupControls">
  <h2>Simulation Settings</h2>
  <div>
    <label>
      NX (grid width):
      <input type="number" id="nxInput" value="400" min="50">
    </label>
  </div>
  <div>
    <label>
      NY (grid height):
      <input type="number" id="nyInput" value="200" min="50">
    </label>
  </div>
  <div>
    <label>
      Steps Per Frame:
      <input type="number" id="stepsInput" value="10" min="1">
    </label>
  </div>
  <button id="startSimBtn">Start Simulation</button>
  <p style="font-size:0.9em; margin-top:10px;">(Simulation will start paused so you can later resume)</p>
</div>

<div id="controls">
  <!-- Simulation & Thermal Controls -->
  <div>
    <label>
      Viscosity:
      <input type="range" id="viscosity" min="0.01" max="0.2" step="0.005" value="0.04">
    </label>
    <span id="viscLabel">0.040</span>
  </div>
  <div>
    <label>
      Damping:
      <input type="range" id="damping" min="0" max="0.1" step="0.005" value="0.02">
    </label>
    <span id="dampLabel">0.020</span>
  </div>
  <div>
    <label>
      Noise Amplitude:
      <input type="range" id="noiseAmplitude" min="0" max="0.2" step="0.001" value="0.01">
    </label>
    <span id="noiseAmpLabel">0.010</span>
  </div>
  <div>
    <label>
      Noise Scale:
      <input type="range" id="noiseScale" min="0.001" max="1" step="0.001" value="0.05">
    </label>
    <span id="noiseScaleLabel">0.050</span>
  </div>
  <div>
    <label>
      Tail Length (sec):
      <input type="range" id="tailLength" min="0.5" max="20" step="0.1" value="10">
    </label>
    <span id="tailLengthLabel">10.0</span>
  </div>
  <div>
    <label>
      Spawn Rate (particles/sec):
      <input type="range" id="spawnRate" min="0" max="200" step="1" value="50">
    </label>
    <span id="spawnRateLabel">50</span>
  </div>
  <div>
    <label>
      Seasonal Blend:
      <input type="range" id="seasonalBlend" min="0" max="1" step="0.01" value="0">
    </label>
    <span id="seasonalBlendLabel">0.00</span>
  </div>
  <!-- New Thermal sliders -->
  <div>
    <label>
      Diffusion (D):
      <input type="range" id="D_const" min="0.0" max="0.2" step="0.005" value="0.0">
    </label>
    <span id="D_constLabel">0.0</span>
  </div>
  <div>
    <label>
      Ground Conductivity (k):
      <input type="range" id="k_const" min="0.0001" max="0.001" step="0.0001" value="0.0007">
    </label>
    <span id="k_constLabel">0.0007</span>
  </div>
  <div>
    <label>
      dpdt:
      <input type="range" id="dpdt" min="100" max="10000" step="1" value="300">
    </label>
    <span id="dpdtLabel">2000</span>
  </div>
  <div>
    <label>
      vc:
      <input type="range" id="vc" min=".1" max="20" step=".1" value="1">
    </label>
    <span id="vcLabel">1</span>
  </div>
  <!-- New d_max slider to cap divergence -->
  <div>
    <label>
      d_max:
      <input type="range" id="d_max" min="0" max="0.005" step="0.0001" value="0.001">
    </label>
    <span id="d_maxLabel">0.001</span>
  </div>
  <!-- Simulation control buttons -->
  <div>
    <button id="resetSim">Reset Sim</button>
    <button id="pauseSim">Pause</button>
    <!-- New Step Frame button -->
    <button id="stepFrame">Step Frame</button>
    <span id="stepCounter">Steps: 0</span>
  </div>
  <div>
    <button id="toggleDivergence">Show Divergence</button>
    <button id="toggleTemperature">Show Temperature</button>
  </div>
  <!-- Map Editor Toggles -->
  <div>
    <button id="enterOriginalEditor">Enter Map Editor</button>
    <button id="enterSeasonalEditor">Enter Seasonal Map Editor</button>
  </div>
  <!-- Original Map Editor Controls -->
  <div id="editorControls" class="editorControls">
    <div>
      <label>
         Brush Size:
         <input type="range" id="brushSize" min="1" max="20" step="1" value="5">
      </label>
      <span id="brushSizeLabel">5</span>
    </div>
    <div>
      <label>
         Brush Value:
         <input type="range" id="brushValue" min="-0.06" max="0.06" step="0.0001" value="0.010">
      </label>
      <span id="brushValueLabel">0.010</span>
    </div>
    <div>
      <label>
         Brush Weight:
         <input type="range" id="brushWeight" min="0" max="1" step="0.01" value="1">
      </label>
      <span id="brushWeightLabel">1.00</span>
    </div>
    <div>
      <button id="clearPerlin">Clear Perlin</button>
      <button id="clearEdit">Clear</button>
      <button id="saveMap">Save Map</button>
      <button id="loadMap">Load Map</button>
      <button id="returnOriginal">Return</button>
      <input type="file" id="loadMapInput" accept="image/png" style="display:none;">
    </div>
    <div style="font-size:0.8em; margin-top:5px;">
      Paint ground temperature using the brush. The brush “pushes” the cell toward the brush target.
    </div>
  </div>
  <!-- Seasonal Map Editor Controls -->
  <div id="seasonalEditorControls" class="editorControls">
    <div>
      <label>
         Brush Size:
         <input type="range" id="s_brushSize" min="1" max="20" step="1" value="5">
      </label>
      <span id="s_brushSizeLabel">5</span>
    </div>
    <div>
      <label>
         Brush Value:
         <input type="range" id="s_brushValue" min="-0.02" max="0.02" step="0.0001" value="0.010">
      </label>
      <span id="s_brushValueLabel">0.010</span>
    </div>
    <div>
      <label>
         Brush Weight:
         <input type="range" id="s_brushWeight" min="0" max="1" step="0.01" value="1">
      </label>
      <span id="s_brushWeightLabel">1.00</span>
    </div>
    <div>
      <button id="clearSeasonal">Clear</button>
      <button id="saveSeasonal">Save Map</button>
      <button id="loadSeasonal">Load Map</button>
      <button id="returnSeasonal">Return</button>
      <input type="file" id="loadSeasonalInput" accept="image/png" style="display:none;">
    </div>
    <div style="font-size:0.8em; margin-top:5px;">
      Paint seasonal ground temperature using the brush.
    </div>
  </div>
  <div style="font-size:0.8em;">
    Ephemeral tracer particle trails are drawn during simulation.
  </div>
</div>

<canvas id="canvas"></canvas>
<script>
  /***** Perlin Noise Implementation *****
   * (Based on Ken Perlin’s improved noise algorithm.)
   *****/
  var PerlinNoise = {
    permutation: [151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,
      69,142,8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,
      11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,134,139,48,27,
      166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,102,
      143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,89,18,169,200,196,135,130,116,188,
      159,86,164,100,109,198,173,186,3,64,52,217,226,250,124,123,5,202,38,147,118,126,255,82,
      85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,248,152,2,44,154,
      163,70,221,153,101,155,167,43,172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,
      112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,
      14,239,107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,138,
      236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180],
    p: [],
    init: function() {
      for (let i = 0; i < 256; i++) {
        this.p[i] = this.permutation[i];
      }
      for (let i = 0; i < 256; i++) {
        this.p[256 + i] = this.p[i];
      }
    },
    fade: function(t) { return t * t * t * (t * (t * 6 - 15) + 10); },
    lerp: function(t, a, b) { return a + t * (b - a); },
    grad: function(hash, x, y, z) {
      let h = hash & 15;
      let u = h < 8 ? x : y;
      let v = h < 4 ? y : (h === 12 || h === 14 ? x : z);
      return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
    },
    noise: function(x, y, z) {
      let X = Math.floor(x) & 255;
      let Y = Math.floor(y) & 255;
      let Z = Math.floor(z) & 255;
      x -= Math.floor(x);
      y -= Math.floor(y);
      z -= Math.floor(z);
      let u = this.fade(x);
      let v = this.fade(y);
      let w = this.fade(z);
      let A = this.p[X] + Y;
      let AA = this.p[A] + Z;
      let AB = this.p[A + 1] + Z;
      let B = this.p[X + 1] + Y;
      let BA = this.p[B] + Z;
      let BB = this.p[B + 1] + Z;
      return this.lerp(w,
          this.lerp(v,
              this.lerp(u, this.grad(this.p[AA], x, y, z),
                           this.grad(this.p[BA], x - 1, y, z)),
              this.lerp(u, this.grad(this.p[AB], x, y - 1, z),
                           this.grad(this.p[BB], x - 1, y - 1, z))
          ),
          this.lerp(v,
              this.lerp(u, this.grad(this.p[AA + 1], x, y, z - 1),
                           this.grad(this.p[BA + 1], x - 1, y, z - 1)),
              this.lerp(u, this.grad(this.p[AB + 1], x, y - 1, z - 1),
                           this.grad(this.p[BB + 1], x - 1, y - 1, z - 1))
          )
      );
    }
  };
  PerlinNoise.init();
  function perlin2(x, y) {
    return PerlinNoise.noise(x, y, 0);
  }
  
  /***** Global Simulation Variables *****/
  // These will be set via the startup menu.
  let NX, NY, stepsPerFrame;
  const cellSize = 4;   // pixels per cell
  const ex = [0,  1,  0, -1,  0,  1, -1, -1,  1];
  const ey = [0,  0,  1,  0, -1,  1,  1, -1, -1];
  const weights = [4/9, 1/9, 1/9, 1/9, 1/9, 1/36, 1/36, 1/36, 1/36];
  const cs2 = 1/3;
  
  // Global arrays – will be initialized later.
  let f, fTemp, baseMap, editMap, seasonalMap, airTemp;
  
  // Other simulation parameters from UI will be read later.
  let viscosity = parseFloat(document.getElementById('viscosity').value);
  let tau = Math.max(0.55, viscosity * 3 + 0.5);
  let damping = parseFloat(document.getElementById('damping').value);
  let noiseAmplitude = parseFloat(document.getElementById('noiseAmplitude').value);
  let noiseScale = parseFloat(document.getElementById('noiseScale').value);
  let tailLength = parseFloat(document.getElementById('tailLength').value);
  let spawnRate = parseFloat(document.getElementById('spawnRate').value);
  let seasonalBlend = parseFloat(document.getElementById('seasonalBlend').value);
  
  // Thermal parameters:
  let D_const = parseFloat(document.getElementById('D_const').value);
  let k_const = parseFloat(document.getElementById('k_const').value);
  let dpdt = parseFloat(document.getElementById('dpdt').value);
  let vc = parseFloat(document.getElementById('vc').value);
  let d_max = parseFloat(document.getElementById('d_max').value);
  
  let showDivergence = false;
  let showTemperature = false;
  
  // Editor state:
  let currentEditor = "none";  // "none", "original", or "seasonal"
  let painting = false;
  let editorMousePos = { x: 0, y: 0 };
  
  // For particles:
  const particleLifetime = 15;
  const particles = [];
  let particleSpawnAccumulator = 0;
  let simTime = 0;
  let simStepCount = 0;
  
  // The simulation starts paused.
  let paused = true;
  
  /***** Initialization Function *****/
  function initSimulation() {
    // Create global arrays based on NX and NY.
    f = new Float32Array(NX * NY * 9);
    fTemp = new Float32Array(NX * NY * 9);
    baseMap = new Float32Array(NX * NY);
    editMap = new Float32Array(NX * NY);
    seasonalMap = new Float32Array(NX * NY);
    airTemp = new Float32Array(NX * NY);
    
    // Generate base temperature map.
    const initialBaseAmplitude = 0.01;
    generateBaseMap(initialBaseAmplitude, noiseScale);
    for (let i = 0; i < NX * NY; i++) {
      editMap[i] = 0;
      seasonalMap[i] = 0;
      airTemp[i] = 0;
    }
    
    // Initialize LBM grid (ρ = 1, u = 0).
    for (let y = 0; y < NY; y++) {
      for (let x = 0; x < NX; x++) {
        const baseIndex = (x + y * NX) * 9;
        for (let i = 0; i < 9; i++) {
          f[baseIndex + i] = weights[i];
        }
      }
    }
    
    // Set canvas dimensions.
    const canvas = document.getElementById('canvas');
    canvas.width = NX * cellSize;
    canvas.height = NY * cellSize;
  }
  
  function generateBaseMap(amplitude, scale) {
    for (let y = 0; y < NY; y++) {
      for (let x = 0; x < NX; x++) {
        baseMap[x + y * NX] = perlin2(x * scale, y * scale) * amplitude;
      }
    }
  }
  
  /***** UI Elements *****/
  const visSlider = document.getElementById('viscosity');
  const viscLabel = document.getElementById('viscLabel');
  const dampSlider = document.getElementById('damping');
  const dampLabel = document.getElementById('dampLabel');
  const noiseAmpSlider = document.getElementById('noiseAmplitude');
  const noiseAmpLabel = document.getElementById('noiseAmpLabel');
  const noiseScaleSlider = document.getElementById('noiseScale');
  const noiseScaleLabel = document.getElementById('noiseScaleLabel');
  const tailLengthSlider = document.getElementById('tailLength');
  const tailLengthLabel = document.getElementById('tailLengthLabel');
  const spawnRateSlider = document.getElementById('spawnRate');
  const spawnRateLabel = document.getElementById('spawnRateLabel');
  const seasonalBlendSlider = document.getElementById('seasonalBlend');
  const seasonalBlendLabel = document.getElementById('seasonalBlendLabel');
  const toggleDivergenceBtn = document.getElementById('toggleDivergence');
  const toggleTemperatureBtn = document.getElementById('toggleTemperature');
  const enterOriginalEditorBtn = document.getElementById('enterOriginalEditor');
  const enterSeasonalEditorBtn = document.getElementById('enterSeasonalEditor');
  const editorControls = document.getElementById('editorControls');
  const seasonalEditorControls = document.getElementById('seasonalEditorControls');
  const brushSizeSlider = document.getElementById('brushSize');
  const brushSizeLabel = document.getElementById('brushSizeLabel');
  const brushValueSlider = document.getElementById('brushValue');
  const brushValueLabel = document.getElementById('brushValueLabel');
  const brushWeightSlider = document.getElementById('brushWeight');
  const brushWeightLabel = document.getElementById('brushWeightLabel');
  const clearPerlinBtn = document.getElementById('clearPerlin');
  const clearEditBtn = document.getElementById('clearEdit');
  const saveMapBtn = document.getElementById('saveMap');
  const loadMapBtn = document.getElementById('loadMap');
  const returnOriginalBtn = document.getElementById('returnOriginal');
  const loadMapInput = document.getElementById('loadMapInput');
  const s_brushSizeSlider = document.getElementById('s_brushSize');
  const s_brushSizeLabel = document.getElementById('s_brushSizeLabel');
  const s_brushValueSlider = document.getElementById('s_brushValue');
  const s_brushValueLabel = document.getElementById('s_brushValueLabel');
  const s_brushWeightSlider = document.getElementById('s_brushWeight');
  const s_brushWeightLabel = document.getElementById('s_brushWeightLabel');
  const clearSeasonalBtn = document.getElementById('clearSeasonal');
  const saveSeasonalBtn = document.getElementById('saveSeasonal');
  const loadSeasonalBtn = document.getElementById('loadSeasonal');
  const returnSeasonalBtn = document.getElementById('returnSeasonal');
  const loadSeasonalInput = document.getElementById('loadSeasonalInput');
  const resetSimBtn = document.getElementById('resetSim');
  const pauseSimBtn = document.getElementById('pauseSim');
  const stepCounter = document.getElementById('stepCounter');
  const stepFrameBtn = document.getElementById('stepFrame');
  const D_constSlider = document.getElementById('D_const');
  const D_constLabel = document.getElementById('D_constLabel');
  const k_constSlider = document.getElementById('k_const');
  const k_constLabel = document.getElementById('k_constLabel');
  const dpdtSlider = document.getElementById('dpdt');
  const dpdtLabel = document.getElementById('dpdtLabel');
  const vcSlider = document.getElementById('vc');
  const vcLabel = document.getElementById('vcLabel');
  const d_maxSlider = document.getElementById('d_max');
  const d_maxLabel = document.getElementById('d_maxLabel');
  
  // Startup controls elements.
  const startSimBtn = document.getElementById('startSimBtn');
  const nxInput = document.getElementById('nxInput');
  const nyInput = document.getElementById('nyInput');
  const stepsInput = document.getElementById('stepsInput');
  
  // Event listeners for simulation sliders.
  visSlider.addEventListener('input', (e) => {
    viscosity = parseFloat(e.target.value);
    tau = Math.max(0.55, viscosity * 3 + 0.5);
    viscLabel.textContent = viscosity.toFixed(3);
  });
  dampSlider.addEventListener('input', (e) => {
    damping = parseFloat(e.target.value);
    dampLabel.textContent = damping.toFixed(3);
  });
  noiseAmpSlider.addEventListener('input', (e) => {
    noiseAmplitude = parseFloat(e.target.value);
    noiseAmpLabel.textContent = noiseAmplitude.toFixed(3);
  });
  noiseScaleSlider.addEventListener('input', (e) => {
    noiseScale = parseFloat(e.target.value);
    noiseScaleLabel.textContent = noiseScale.toFixed(3);
  });
  tailLengthSlider.addEventListener('input', (e) => {
    tailLength = parseFloat(e.target.value);
    tailLengthLabel.textContent = tailLength.toFixed(1);
  });
  spawnRateSlider.addEventListener('input', (e) => {
    spawnRate = parseFloat(e.target.value);
    spawnRateLabel.textContent = spawnRate;
  });
  seasonalBlendSlider.addEventListener('input', (e) => {
    seasonalBlend = parseFloat(e.target.value);
    seasonalBlendLabel.textContent = seasonalBlend.toFixed(2);
  });
  D_constSlider.addEventListener('input', (e) => {
    D_const = parseFloat(e.target.value);
    D_constLabel.textContent = D_const.toFixed(3);
  });
  k_constSlider.addEventListener('input', (e) => {
    k_const = parseFloat(e.target.value);
    k_constLabel.textContent = k_const.toFixed(3);
  });
  dpdtSlider.addEventListener('input', (e) => {
    dpdt = parseFloat(e.target.value);
    dpdtLabel.textContent = dpdt.toFixed(2);
  });
  vcSlider.addEventListener('input', (e) => {
    vc = parseFloat(e.target.value);
    vcLabel.textContent = vc.toFixed(0);
  });
  d_maxSlider.addEventListener('input', (e) => {
    d_max = parseFloat(e.target.value);
    d_maxLabel.textContent = d_max.toFixed(3);
  });
  
  toggleDivergenceBtn.addEventListener('click', () => {
    showDivergence = !showDivergence;
    if (showDivergence) { 
      showTemperature = false;
      toggleTemperatureBtn.textContent = "Show Temperature";
      toggleDivergenceBtn.textContent = "Hide Divergence";
    } else {
      toggleDivergenceBtn.textContent = "Show Divergence";
    }
  });
  toggleTemperatureBtn.addEventListener('click', () => {
    showTemperature = !showTemperature;
    if (showTemperature) {
      showDivergence = false;
      toggleDivergenceBtn.textContent = "Show Divergence";
      toggleTemperatureBtn.textContent = "Hide Temperature";
    } else {
      toggleTemperatureBtn.textContent = "Show Temperature";
    }
  });
  
  enterOriginalEditorBtn.addEventListener('click', () => {
    currentEditor = "original";
    editorControls.style.display = 'block';
    enterOriginalEditorBtn.style.display = 'none';
    enterSeasonalEditorBtn.style.display = 'none';
  });
  enterSeasonalEditorBtn.addEventListener('click', () => {
    currentEditor = "seasonal";
    seasonalEditorControls.style.display = 'block';
    enterOriginalEditorBtn.style.display = 'none';
    enterSeasonalEditorBtn.style.display = 'none';
  });
  returnOriginalBtn.addEventListener('click', () => {
    currentEditor = "none";
    editorControls.style.display = 'none';
    enterOriginalEditorBtn.style.display = 'inline-block';
    enterSeasonalEditorBtn.style.display = 'inline-block';
  });
  returnSeasonalBtn.addEventListener('click', () => {
    currentEditor = "none";
    seasonalEditorControls.style.display = 'none';
    enterOriginalEditorBtn.style.display = 'inline-block';
    enterSeasonalEditorBtn.style.display = 'inline-block';
  });
  
  brushSizeSlider.addEventListener('input', (e) => {
    brushSizeLabel.textContent = e.target.value;
  });
  brushValueSlider.addEventListener('input', (e) => {
    brushValueLabel.textContent = parseFloat(e.target.value).toFixed(3);
  });
  brushWeightSlider.addEventListener('input', (e) => {
    brushWeightLabel.textContent = parseFloat(e.target.value).toFixed(2);
  });
  s_brushSizeSlider.addEventListener('input', (e) => {
    s_brushSizeLabel.textContent = e.target.value;
  });
  s_brushValueSlider.addEventListener('input', (e) => {
    s_brushValueLabel.textContent = parseFloat(e.target.value).toFixed(3);
  });
  s_brushWeightSlider.addEventListener('input', (e) => {
    s_brushWeightLabel.textContent = parseFloat(e.target.value).toFixed(2);
  });
  
  clearPerlinBtn.addEventListener('click', () => {
    generateBaseMap(0.01, noiseScale);
  });
  clearEditBtn.addEventListener('click', () => {
    for (let i = 0; i < NX * NY; i++) {
      baseMap[i] = 0;
      editMap[i] = 0;
    }
  });
  function saveOriginalMapToPNG() {
    const offCanvas = document.createElement('canvas');
    offCanvas.width = NX;
    offCanvas.height = NY;
    const offCtx = offCanvas.getContext('2d');
    const imageData = offCtx.createImageData(NX, NY);
    for (let y = 0; y < NY; y++) {
      for (let x = 0; x < NX; x++) {
        const idx = x + y * NX;
        let T = baseMap[idx] + editMap[idx];
        let col = Math.floor(((T + 0.02) / 0.04) * 255);
        col = Math.max(0, Math.min(255, col));
        const pixelIndex = (x + y * NX) * 4;
        imageData.data[pixelIndex] = col;
        imageData.data[pixelIndex+1] = col;
        imageData.data[pixelIndex+2] = col;
        imageData.data[pixelIndex+3] = 255;
      }
    }
    offCtx.putImageData(imageData, 0, 0);
    const link = document.createElement('a');
    link.download = 'ground_temperature_map.png';
    link.href = offCanvas.toDataURL('image/png');
    link.click();
  }
  saveMapBtn.addEventListener('click', () => {
    saveOriginalMapToPNG();
    currentEditor = "none";
    editorControls.style.display = 'none';
    enterOriginalEditorBtn.style.display = 'inline-block';
    enterSeasonalEditorBtn.style.display = 'inline-block';
  });
  loadMapBtn.addEventListener('click', () => {
    loadMapInput.click();
  });
  loadMapInput.addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = function(event) {
      const img = new Image();
      img.onload = function() {
        const offCanvas = document.createElement('canvas');
        offCanvas.width = NX;
        offCanvas.height = NY;
        const offCtx = offCanvas.getContext('2d');
        offCtx.drawImage(img, 0, 0, NX, NY);
        const imageData = offCtx.getImageData(0, 0, NX, NY);
        for (let y = 0; y < NY; y++) {
          for (let x = 0; x < NX; x++) {
            const pixelIndex = (x + y * NX) * 4;
            const col = imageData.data[pixelIndex];
            const T = (col / 255) * 0.04 - 0.02;
            const idx = x + y * NX;
            baseMap[idx] = T;
            editMap[idx] = 0;
          }
        }
      }
      img.src = event.target.result;
    }
    reader.readAsDataURL(file);
  });
  
  clearSeasonalBtn.addEventListener('click', () => {
    for (let i = 0; i < NX * NY; i++) {
      seasonalMap[i] = 0;
    }
  });
  function saveSeasonalMapToPNG() {
    const offCanvas = document.createElement('canvas');
    offCanvas.width = NX;
    offCanvas.height = NY;
    const offCtx = offCanvas.getContext('2d');
    const imageData = offCtx.createImageData(NX, NY);
    for (let y = 0; y < NY; y++) {
      for (let x = 0; x < NX; x++) {
        const idx = x + y * NX;
        let T = seasonalMap[idx];
        let col = Math.floor(((T + 0.02) / 0.04) * 255);
        col = Math.max(0, Math.min(255, col));
        const pixelIndex = (x + y * NX) * 4;
        imageData.data[pixelIndex] = col;
        imageData.data[pixelIndex+1] = col;
        imageData.data[pixelIndex+2] = col;
        imageData.data[pixelIndex+3] = 255;
      }
    }
    offCtx.putImageData(imageData, 0, 0);
    const link = document.createElement('a');
    link.download = 'seasonal_temperature_map.png';
    link.href = offCanvas.toDataURL('image/png');
    link.click();
  }
  saveSeasonalBtn.addEventListener('click', () => {
    saveSeasonalMapToPNG();
    currentEditor = "none";
    seasonalEditorControls.style.display = 'none';
    enterOriginalEditorBtn.style.display = 'inline-block';
    enterSeasonalEditorBtn.style.display = 'inline-block';
  });
  loadSeasonalBtn.addEventListener('click', () => {
    loadSeasonalInput.click();
  });
  loadSeasonalInput.addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = function(event) {
      const img = new Image();
      img.onload = function() {
        const offCanvas = document.createElement('canvas');
        offCanvas.width = NX;
        offCanvas.height = NY;
        const offCtx = offCanvas.getContext('2d');
        offCtx.drawImage(img, 0, 0, NX, NY);
        const imageData = offCtx.getImageData(0, 0, NX, NY);
        for (let y = 0; y < NY; y++) {
          for (let x = 0; x < NX; x++) {
            const pixelIndex = (x + y * NX) * 4;
            const col = imageData.data[pixelIndex];
            const T = (col / 255) * 0.04 - 0.02;
            const idx = x + y * NX;
            seasonalMap[idx] = T;
          }
        }
      }
      img.src = event.target.result;
    }
    reader.readAsDataURL(file);
  });
  
  resetSimBtn.addEventListener('click', () => {
    for (let y = 0; y < NY; y++) {
      for (let x = 0; x < NX; x++) {
        const baseIndex = (x + y * NX) * 9;
        for (let i = 0; i < 9; i++) {
          f[baseIndex + i] = weights[i];
        }
      }
    }
    particles.length = 0;
    particleSpawnAccumulator = 0;
    simTime = 0;
    simStepCount = 0;
  });
  pauseSimBtn.addEventListener('click', () => {
    paused = !paused;
    pauseSimBtn.textContent = paused ? "Resume" : "Pause";
  });
  stepFrameBtn.addEventListener('click', () => {
    if (!paused) {
      alert("Please pause the simulation before stepping frame by frame.");
      return;
    }
    stepFrame();
  });
  
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  
  function spawnParticle() {
    particles.push({
      x: Math.random() * canvas.width,
      y: Math.random() * canvas.height,
      age: 0,
      trail: []
    });
  }
  
  function stepLBM(dtStep) {
    const feqArray = new Float32Array(NX * NY * 9);
    const cellVel = new Array(NX * NY);
    const cellVavg = new Float32Array(NX * NY);
    
    for (let y = 0; y < NY; y++) {
      for (let x = 0; x < NX; x++) {
        const index = x + y * NX;
        const baseIndex = index * 9;
        let rho = 0, momX = 0, momY = 0;
        for (let i = 0; i < 9; i++) {
          const fi = f[baseIndex + i];
          rho += fi;
          momX += fi * ex[i];
          momY += fi * ey[i];
        }
        const ux = momX / rho;
        const uy = momY / rho;
        cellVel[index] = { ux, uy };
        cellVavg[index] = (Math.abs(ux) + Math.abs(uy)) / 2;
        const uSq = ux * ux + uy * uy;
        for (let i = 0; i < 9; i++) {
          const e_dot_u = ex[i] * ux + ey[i] * uy;
          feqArray[baseIndex + i] = weights[i] * rho * (1 + 3 * e_dot_u + 4.5 * e_dot_u * e_dot_u - 1.5 * uSq);
        }
      }
    }
    
    const t_inc_average = new Float32Array(NX * NY);
    for (let y = 0; y < NY; y++) {
      for (let x = 0; x < NX; x++) {
        const index = x + y * NX;
        let sum = 0, weightSum = 0;
        for (let dy = -1; dy <= 1; dy++) {
          for (let dx = -1; dx <= 1; dx++) {
            if (dx === 0 && dy === 0) continue;
            const nx = (x + dx + NX) % NX;
            const ny = (y + dy + NY) % NY;
            const nIndex = nx + ny * NX;
            const rx = -dx, ry = -dy;
            const nVel = cellVel[nIndex];
            const dot = nVel.ux * rx + nVel.uy * ry;
            if (dot > 0) {
              weightSum += dot;
              sum += dot * airTemp[nIndex];
            }
          }
        }
        t_inc_average[index] = weightSum > 0 ? (sum / weightSum) : airTemp[index];
      }
    }
    
    const t_inc = new Float32Array(NX * NY);
    for (let y = 0; y < NY; y++) {
      for (let x = 0; x < NX; x++) {
        const index = x + y * NX;
        const t_prior = airTemp[index];
        const alpha = Math.min(1, vc * cellVavg[index]);
        t_inc[index] = alpha * t_inc_average[index] + (1 - alpha) * t_prior;
      }
    }
    
    const t_avg_adj = new Float32Array(NX * NY);
    for (let y = 0; y < NY; y++) {
      for (let x = 0; x < NX; x++) {
        const index = x + y * NX;
        let s = 0, cnt = 0;
        for (let dy = -1; dy <= 1; dy++) {
          for (let dx = -1; dx <= 1; dx++) {
            if (dx === 0 && dy === 0) continue;
            const nx = (x + dx + NX) % NX;
            const ny = (y + dy + NY) % NY;
            const nIndex = nx + ny * NX;
            s += t_inc[nIndex];
            cnt++;
          }
        }
        t_avg_adj[index] = s / cnt;
      }
    }
    
    const S_array = new Float32Array(NX * NY);
    const t_final_array = new Float32Array(NX * NY);
    for (let y = 0; y < NY; y++) {
      for (let x = 0; x < NX; x++) {
        const index = x + y * NX;
        const t_ground = baseMap[index] + editMap[index] + seasonalBlend * seasonalMap[index];
        const inc = t_inc[index];
        const avg_adj = t_avg_adj[index];
        const d_diff = D_const * (avg_adj - inc);
        const t_diff = k_const * (t_ground - inc);
        let S_val = t_diff * dpdt;
        S_val = Math.max(-d_max, Math.min(d_max, S_val));
        S_array[index] = S_val;
        t_final_array[index] = inc + t_diff;
      }
    }
    lastS = S_array;
    
    for (let y = 0; y < NY; y++) {
      for (let x = 0; x < NX; x++) {
        const index = x + y * NX;
        const baseIndex = index * 9;
        for (let i = 0; i < 9; i++) {
          f[baseIndex + i] = f[baseIndex + i] - (f[baseIndex + i] - feqArray[baseIndex + i]) / tau + S_array[index] * weights[i];
        }
      }
    }
    
    for (let y = 0; y < NY; y++) {
      for (let x = 0; x < NX; x++) {
        const index = x + y * NX;
        const baseIndex = index * 9;
        for (let i = 0; i < 9; i++) {
          const nx = (x + ex[i] + NX) % NX;
          const ny = (y + ey[i] + NY) % NY;
          const nBaseIndex = (nx + ny * NX) * 9;
          fTemp[nBaseIndex + i] = f[baseIndex + i];
        }
      }
    }
    let temp = f;
    f = fTemp;
    fTemp = temp;
    
    for (let y = 1; y < NY - 1; y++) {
      for (let x = 1; x < NX - 1; x++) {
        const index = (x + y * NX) * 9;
        for (let i = 0; i < 9; i++) {
          let sum = 0;
          let count = 0;
          for (let dy = -1; dy <= 1; dy++) {
            for (let dx = -1; dx <= 1; dx++) {
              const nIndex = ((x + dx) + (y + dy) * NX) * 9 + i;
              sum += f[nIndex];
              count++;
            }
          }
          f[index + i] = sum / count;
        }
      }
    }
    
    for (let y = 0; y < NY; y++) {
      for (let x = 0; x < NX; x++) {
        const index = x + y * NX;
        const baseIndex = index * 9;
        for (let i = 0; i < 9; i++) {
          f[baseIndex + i] = weights[i] + (f[baseIndex + i] - weights[i]) * (1 - damping * dtStep);
        }
      }
    }
    
    for (let i = 0; i < NX * NY; i++) {
      airTemp[i] = t_final_array[i];
    }
    
    simStepCount += stepsPerFrame;
  }
  
  function getVelocityAt(gx, gy) {
    let i = Math.floor(gx);
    let j = Math.floor(gy);
    const di = gx - i, dj = gy - j;
    i = Math.max(0, Math.min(i, NX - 2));
    j = Math.max(0, Math.min(j, NY - 2));
    function cellVelocity(i, j) {
      const baseIndex = (i + j * NX) * 9;
      let rho = 0, ux = 0, uy = 0;
      for (let k = 0; k < 9; k++) {
        const f_val = f[baseIndex + k];
        rho += f_val;
        ux += f_val * ex[k];
        uy += f_val * ey[k];
      }
      return { ux: ux / rho, uy: uy / rho };
    }
    const v00 = cellVelocity(i, j);
    const v10 = cellVelocity(i + 1, j);
    const v01 = cellVelocity(i, j + 1);
    const v11 = cellVelocity(i + 1, j + 1);
    const ux = (1 - di) * (1 - dj) * v00.ux +
               di * (1 - dj) * v10.ux +
               (1 - di) * dj * v01.ux +
               di * dj * v11.ux;
    const uy = (1 - di) * (1 - dj) * v00.uy +
               di * (1 - dj) * v10.uy +
               (1 - di) * dj * v01.uy +
               di * dj * v11.uy;
    return { ux, uy };
  }
  
  function updateParticles(dt) {
    simTime += dt;
    const speedFactor = 200;
    for (let i = particles.length - 1; i >= 0; i--) {
      let p = particles[i];
      p.trail.push({ x: p.x, y: p.y, t: simTime });
      while (p.trail.length > 0 && (simTime - p.trail[0].t) > tailLength) {
        p.trail.shift();
      }
      const gx = p.x / cellSize;
      const gy = p.y / cellSize;
      const vel = getVelocityAt(gx, gy);
      p.x += vel.ux * speedFactor * dt;
      p.y += vel.uy * speedFactor * dt;
      if (p.x < 0) p.x += canvas.width;
      if (p.y < 0) p.y += canvas.height;
      if (p.x >= canvas.width) p.x -= canvas.width;
      if (p.y >= canvas.height) p.y -= canvas.height;
      p.age += dt;
      if (p.age > particleLifetime) {
        particles.splice(i, 1);
      }
    }
    particleSpawnAccumulator += dt * spawnRate;
    while (particleSpawnAccumulator >= 1) {
      spawnParticle();
      particleSpawnAccumulator -= 1;
    }
  }
  
  function paintAtOriginal(clientX, clientY) {
    const rect = canvas.getBoundingClientRect();
    const mx = clientX - rect.left;
    const my = clientY - rect.top;
    const gridX = Math.floor(mx / cellSize);
    const gridY = Math.floor(my / cellSize);
    const brushRad = parseInt(brushSizeSlider.value);
    const brushTarget = parseFloat(brushValueSlider.value);
    const weight = parseFloat(brushWeightSlider.value);
    for (let j = -brushRad; j <= brushRad; j++) {
      for (let i = -brushRad; i <= brushRad; i++) {
        const dist = Math.sqrt(i * i + j * j);
        if (dist <= brushRad) {
          let factor = (1 - (dist / brushRad)) * weight;
          const gx = gridX + i;
          const gy = gridY + j;
          if (gx >= 0 && gx < NX && gy >= 0 && gy < NY) {
            const idx = gx + gy * NX;
            const currentTotal = baseMap[idx] + editMap[idx];
            const newTotal = (1 - factor) * currentTotal + factor * brushTarget;
            let newEdit = newTotal - baseMap[idx];
            if (newEdit > 0.02) newEdit = 0.02;
            if (newEdit < -0.02) newEdit = -0.02;
            editMap[idx] = newEdit;
          }
        }
      }
    }
  }
  function paintAtSeasonal(clientX, clientY) {
    const rect = canvas.getBoundingClientRect();
    const mx = clientX - rect.left;
    const my = clientY - rect.top;
    const gridX = Math.floor(mx / cellSize);
    const gridY = Math.floor(my / cellSize);
    const brushRad = parseInt(s_brushSizeSlider.value);
    const brushTarget = parseFloat(s_brushValueSlider.value);
    const weight = parseFloat(s_brushWeightSlider.value);
    for (let j = -brushRad; j <= brushRad; j++) {
      for (let i = -brushRad; i <= brushRad; i++) {
        const dist = Math.sqrt(i * i + j * j);
        if (dist <= brushRad) {
          let factor = (1 - (dist / brushRad)) * weight;
          const gx = gridX + i;
          const gy = gridY + j;
          if (gx >= 0 && gx < NX && gy >= 0 && gy < NY) {
            const idx = gx + gy * NX;
            const current = seasonalMap[idx];
            const newVal = (1 - factor) * current + factor * brushTarget;
            seasonalMap[idx] = Math.max(-0.02, Math.min(0.02, newVal));
          }
        }
      }
    }
  }
  
  canvas.addEventListener('mousedown', (e) => {
    if (currentEditor === "none") return;
    painting = true;
    if (currentEditor === "original") {
      paintAtOriginal(e.clientX, e.clientY);
    } else if (currentEditor === "seasonal") {
      paintAtSeasonal(e.clientX, e.clientY);
    }
    const rect = canvas.getBoundingClientRect();
    editorMousePos.x = e.clientX - rect.left;
    editorMousePos.y = e.clientY - rect.top;
  });
  canvas.addEventListener('mousemove', (e) => {
    if (currentEditor === "none" || !painting) return;
    if (currentEditor === "original") {
      paintAtOriginal(e.clientX, e.clientY);
    } else if (currentEditor === "seasonal") {
      paintAtSeasonal(e.clientX, e.clientY);
    }
    const rect = canvas.getBoundingClientRect();
    editorMousePos.x = e.clientX - rect.left;
    editorMousePos.y = e.clientY - rect.top;
  });
  canvas.addEventListener('mouseup', () => {
    if (currentEditor !== "none") painting = false;
  });
  canvas.addEventListener('mouseleave', () => {
    if (currentEditor !== "none") painting = false;
  });
  
  function drawSimulation() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    if (currentEditor === "original") {
      for (let y = 0; y < NY; y++) {
        for (let x = 0; x < NX; x++) {
          const idx = x + y * NX;
          let T = baseMap[idx] + editMap[idx];
          let col = Math.floor(((T + 0.02) / 0.04) * 255);
          col = Math.max(0, Math.min(255, col));
          ctx.fillStyle = `rgb(${col},${col},${col})`;
          ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
        }
      }
      if (painting) {
        ctx.strokeStyle = 'red';
        ctx.lineWidth = 2;
        const r = parseInt(brushSizeSlider.value) * cellSize;
        ctx.beginPath();
        ctx.arc(editorMousePos.x, editorMousePos.y, r, 0, 2 * Math.PI);
        ctx.stroke();
      }
    } else if (currentEditor === "seasonal") {
      for (let y = 0; y < NY; y++) {
        for (let x = 0; x < NX; x++) {
          const idx = x + y * NX;
          let T = seasonalMap[idx];
          let col = Math.floor(((T + 0.02) / 0.04) * 255);
          col = Math.max(0, Math.min(255, col));
          ctx.fillStyle = `rgb(${col},${col},${col})`;
          ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
        }
      }
      if (painting) {
        ctx.strokeStyle = 'red';
        ctx.lineWidth = 2;
        const r = parseInt(s_brushSizeSlider.value) * cellSize;
        ctx.beginPath();
        ctx.arc(editorMousePos.x, editorMousePos.y, r, 0, 2 * Math.PI);
        ctx.stroke();
      }
    } else {
      if (showTemperature) {
        for (let y = 0; y < NY; y++) {
          for (let x = 0; x < NX; x++) {
            const idx = x + y * NX;
            let T_air = airTemp[idx];
            let col = Math.floor(((T_air + 0.02) / 0.04) * 255);
            col = Math.max(0, Math.min(255, col));
            ctx.fillStyle = `rgb(${col},${col},${col})`;
            ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
          }
        }
      } else if (showDivergence) {
        for (let y = 0; y < NY; y++) {
          for (let x = 0; x < NX; x++) {
            const idx = x + y * NX;
            let S_val = lastS[idx];
            let col = Math.floor(((S_val + 0.02) / 0.04) * 255);
            col = Math.max(0, Math.min(255, col));
            ctx.fillStyle = `rgb(${col},${col},${col})`;
            ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
          }
        }
      } else {
        ctx.fillStyle = 'black';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      }
      for (let p of particles) {
        if (p.trail.length > 1) {
          for (let i = 0; i < p.trail.length - 1; i++) {
            let p1 = p.trail[i];
            let p2 = p.trail[i + 1];
            if (Math.abs(p1.x - p2.x) > canvas.width / 2 || Math.abs(p1.y - p2.y) > canvas.height / 2)
              continue;
            let alpha1 = (p1.t - (simTime - tailLength)) / tailLength;
            let alpha2 = (p2.t - (simTime - tailLength)) / tailLength;
            let segAlpha = (alpha1 + alpha2) / 2;
            ctx.strokeStyle = `rgba(0,255,255,${segAlpha.toFixed(2)})`;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.stroke();
          }
        }
        ctx.fillStyle = 'rgba(0,255,255,1)';
        ctx.beginPath();
        ctx.arc(p.x, p.y, 2, 0, 2 * Math.PI);
        ctx.fill();
      }
    }
  }
  
  function loop() {
    const now = performance.now();
    const dt = (now - lastTime) / 1000;
    lastTime = now;
    if (currentEditor === "none" && !paused) {
      const dtStep = dt / stepsPerFrame;
      for (let i = 0; i < stepsPerFrame; i++) {
        stepLBM(dtStep);
      }
      updateParticles(dt);
    }
    stepCounter.textContent = "Steps: " + simStepCount;
    drawSimulation();
    requestAnimationFrame(loop);
  }
  
  function stepFrame() {
    const dt = 1/60;
    const dtStep = dt / stepsPerFrame;
    for (let i = 0; i < stepsPerFrame; i++) {
      stepLBM(dtStep);
    }
    updateParticles(dt);
  }
  
  let lastTime = performance.now();
  
  // Startup: when "Start Simulation" is clicked, read the settings, initialize the simulation, hide the overlay, and start the loop.
  startSimBtn.addEventListener('click', () => {
    console.log("Start Simulation button clicked.");
    NX = parseInt(nxInput.value);
    NY = parseInt(nyInput.value);
    stepsPerFrame = parseInt(stepsInput.value);
    initSimulation();
    document.getElementById('startupControls').style.display = 'none';
    lastTime = performance.now();
    requestAnimationFrame(loop);
  });
</script>
</body>
</html>
